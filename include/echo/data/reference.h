#ifndef _ECHO_DATA_REFERENCE_H_
#define _ECHO_DATA_REFERENCE_H_

#include <string>
#include <list>

#include <echo/util/logging/level.h>
#include <echo/context.h>
#include <echo/engine/edition.h>
/*
  import java.io.UnsupportedEncodingException;
  import java.util.ArrayList;
*/

namespace echo {
namespace data {

/**
 * Reference to a Uniform Resource Identifier (URI). Contrary to the
 * java.net.URI class, this interface represents mutable references. It strictly
 * conforms to the RFC 3986 specifying URIs and follow its naming conventions.<br>
 * 
 * <pre>
 * URI reference        = absolute-reference | relative-reference
 * 
 * absolute-reference   = scheme &quot;:&quot; scheme-specific-part [ &quot;#&quot; fragment ]
 * scheme-specific-part = ( hierarchical-part [ &quot;?&quot; query ] ) | opaque-part
 * hierarchical-part    = ( &quot;//&quot; authority path-abempty ) | path-absolute | path-rootless | path-empty
 * authority            = [ user-info &quot;@&quot; ] host-domain [ &quot;:&quot; host-port ]
 * 
 * relative-reference   = relative-part [ &quot;?&quot; query ] [ &quot;#&quot; fragment ]
 * relative-part        = ( &quot;//&quot; authority path-abempty ) | path-absolute | path-noscheme | path-empty
 * 
 * path-abempty         = begins with &quot;/&quot; or is empty
 * path-absolute        = begins with &quot;/&quot; but not &quot;//&quot;
 * path-noscheme        = begins with a non-colon segment
 * path-rootless        = begins with a segment
 * path-empty           = zero characters
 * </pre>
 * 
 * <p>
 * Note that this class doesn't encode or decode the reserved characters. It
 * assumes that the URIs or the URI parts passed in are properly encoded using
 * the standard URI encoding mechanism. You can use the static "encode()" and
 * "decode()" methods for this purpose. Note that if an invalid URI character is
 * detected by the constructor or one of the setters, a trace will be logged and
 * the character will be automatically encoded.
 * </p>
 * <p>
 * The fundamental point to underline is the difference between an URI
 * "reference" and an URI. Contrary to an URI (the target identifier of a REST
 * resource), an URI reference can be relative (with or without query and
 * fragment part). This relative URI reference can then be resolved against a
 * base reference via the getTargetRef() method which will return a new resolved
 * Reference instance, an absolute URI reference with no base reference and with
 * no dot-segments (the path segments "." and "..").
 * </p>
 * <p>
 * You can also apply the getTargetRef() method on absolute references in order
 * to solve the dot-segments. Note that applying the getRelativeRef() method on
 * an absolute reference returns the current reference relatively to a base
 * reference, if any, and solves the dot-segments.
 * </p>
 * <p>
 * The Reference stores its data as a single string, the one passed to the
 * constructor. This string can always be obtained using the toString() method.
 * A couple of integer indexes are maintained to improve the extraction time of
 * various reference properties (URI components).
 * </p>
 * <p>
 * When you modify a specific component of the URI reference, via the setPath()
 * method for example, the internal string is simply regenerated by updating
 * only the relevant part. We try as much as possible to protect the bytes given
 * to the Reference class instead of transparently parsing and normalizing the
 * URI data. Our idea is to protect encodings and special characters in all case
 * and reduce the memory size taken by this class while making Reference
 * instances mutable.
 * </p>
 * <p>
 * Because the base reference is only a property of the Reference ("baseRef").
 * When you use the "Reference(base, path)" constructor, it is equivalent to
 * doing:<br>
 * ref = new Reference(path);<br>
 * ref.setBaseRef(base);
 * </p>
 * <p>
 * The base ref is not automatically resolved or "merged" with the rest of the
 * reference information (the path here). For example, this let's you reuse a
 * single reference as the base of several relative references. If you modify
 * the base reference, all relative references are still accurate.
 * </p>
 * Note that the name and value properties are thread safe, stored in volatile
 * members.
 * 
 * @author Jerome Louvel
 * @see <a href="http://www.faqs.org/rfcs/rfc3986.html">RFC 3986</a>
 */
class Reference {

 public:

  /**
   * Decodes a given string using the standard URI encoding mechanism and the
   * UTF-8 character set.
   * 
   * @param toDecode
   *            The string to decode.
   * @return The decoded string.
   */
  static std::string decode(std::string toDecode);

  /**
   * Decodes a given string using the standard URI encoding mechanism. If the
   * provided character set is NULL, the string is returned but not decoded.
   * <em><strong>Note:</strong> The <a
   * href="http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars">
   * World Wide Web Consortium Recommendation</a> states that UTF-8 should be
   * used. Not doing so may introduce incompatibilities.</em>
   * 
   * @param toDecode
   *            The string to decode.
   * @param characterSet
   *            The name of a supported character encoding.
   * @return The decoded string or NULL if the named character encoding is not
   *         supported.
   */
  static std::string decode(std::string toDecode, 
                            CharacterSet characterSet);

  /**
   * Encodes a given string using the standard URI encoding mechanism and the
   * UTF-8 character set.
   * 
   * @param toEncode
   *            The string to encode.
   * @return The encoded string.
   */
  static std::string encode(std::string toEncode);

  /**
   * Encodes a given string using the standard URI encoding mechanism. If the
   * provided character set is NULL, the string is returned but not encoded.
   * 
   * <em><strong>Note:</strong> The <a
   * href="http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars">
   * World Wide Web Consortium Recommendation</a> states that UTF-8 should be
   * used. Not doing so may introduce incompatibilites.</em>
   * 
   * @param toEncode
   *            The string to encode.
   * @param characterSet
   *            The supported character encoding.
   * @return The encoded string or NULL if the named character encoding is not
   *         supported.
   */
  static std::string encode(std::string toEncode, CharacterSet characterSet);

  /**
   * Indicates if the given character is a generic URI component delimiter
   * character.
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is a generic URI component delimiter
   *         character.
   */
  static bool isGenericDelimiter(int character);

  /**
   * Indicates if the given character is a reserved URI character.
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is a reserved URI character.
   */
  static bool isReserved(int character) {
    return isGenericDelimiter(character) || isSubDelimiter(character);
  }

  /**
   * Indicates if the given character is an URI subcomponent delimiter
   * character.
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is an URI subcomponent delimiter
   *         character.
   */
  static bool isSubDelimiter(int character);

  /**
   * Indicates if the given character is an unreserved URI character.
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is an unreserved URI character.
   */
  static bool isUnreserved(int character);

  /**
   * Indicates if the given character is a valid URI character.
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is a valid URI character.
   */
  static bool isValid(int character);

  /**
   * Creates a reference string from its parts.
   * 
   * @param scheme
   *            The scheme ("http", "https" or "ftp").
   * @param hostName
   *            The host name or IP address.
   * @param hostPort
   *            The host port (default ports are correctly ignored).
   * @param path
   *            The path component for hierarchical identifiers.
   * @param query
   *            The optional query component for hierarchical identifiers.
   * @param fragment
   *            The optional fragment identifier.
   * @return The reference as std::string.
   */
  static std::string toString(std::string scheme, std::string hostName,
                              Integer hostPort, std::string path, std::string query, std::string fragment);

  /**
   * Creates a relative reference string from its parts.
   * 
   * @param relativePart
   *            The relative part component.
   * @param query
   *            The optional query component for hierarchical identifiers.
   * @param fragment
   *            The optional fragment identifier.
   * @return The relative reference as a std::string.
   */
  static std::string toString(std::string relativePart, std::string query,
                              std::string fragment);

  /**
   * Creates a reference string from its parts.
   * 
   * @param scheme
   *            The scheme ("http", "https" or "ftp").
   * @param host
   *            The host name or IP address plus the optional port number.
   * @param path
   *            The path component for hierarchical identifiers.
   * @param query
   *            The optional query component for hierarchical identifiers.
   * @param fragment
   *            The optional fragment identifier.
   * @return The reference a String.
   */
  static std::string toString(std::string scheme, std::string host, std::string path,
                              std::string query, std::string fragment);

  /**
   * Empty constructor.
   */
  Reference() {
    Reference((Reference) NULL, (std::string) NULL);
  }

  /**
   * Constructor from an {@link java.net.URI} instance.
   * 
   * @param uri
   *            The {@link java.net.URI} instance.
   */
  Reference(java.net.URI uri) {
    Reference(uri.toString());
  }

  /**
   * Constructor from an {@link java.net.URL} instance.
   * 
   * @param url
   *            The {@link java.net.URL} instance.
   */
  Reference(java.net.URL url) {
    Reference(url.toString());
  }

  /**
   * Constructor for a protocol and host name. Uses the default port for the
   * given protocol.
   * 
   * @param protocol
   *            Protocol/scheme to use
   * @param hostName
   *            The host name or IP address.
   */
  Reference(Protocol protocol, std::string hostName) {
    Reference(protocol, hostName, protocol.getDefaultPort());
  }

  /**
   * Constructor for a protocol, host name and host port
   * 
   * @param protocol
   *            Protocol/scheme to use
   * @param hostName
   *            The host name or IP address.
   * @param hostPort
   *            The host port (default ports are correctly ignored).
   */
  Reference(Protocol protocol, std::string hostName, int hostPort) {
    Reference(protocol.getSchemeName(), hostName, hostPort, NULL, NULL, NULL);
  }

  /**
   * Clone constructor.
   * 
   * @param ref
   *            The reference to clone.
   */
  Reference(Reference ref) {
    Reference(ref.baseRef, ref.internalRef);
  }

  /**
   * Constructor from an URI reference (most likely relative).
   * 
   * @param baseRef
   *            The base reference.
   * @param uriReference
   *            The URI reference, either absolute or relative.
   */
  Reference(Reference baseRef, Reference uriReference) {
    Reference(baseRef, uriReference.toString());
  }

  /**
   * Constructor from an URI reference (most likely relative).
   * 
   * @param baseRef
   *            The base reference.
   * @param uriRef
   *            The URI reference, either absolute or relative.
   */
  Reference(Reference baseRef, std::string uriRef);

  /**
   * Constructor of relative reference from its parts.
   * 
   * @param baseRef
   *            The base reference.
   * @param relativePart
   *            The relative part component (most of the time it is the path
   *            component).
   * @param query
   *            The optional query component for hierarchical identifiers.
   * @param fragment
   *            The optional fragment identifier.
   */
  Reference(Reference baseRef, std::string relativePart, std::string query,
            std::string fragment) {
    Reference(baseRef, toString(relativePart, query, fragment));
  }

  /**
   * Constructor from an URI reference.
   * 
   * @param uriReference
   *            The URI reference, either absolute or relative.
   */
  Reference(std::string uriReference) {
    Reference((Reference) NULL, uriReference);
  }

  /**
   * Constructor from an identifier and a fragment.
   * 
   * @param identifier
   *            The resource identifier.
   * @param fragment
   *            The fragment identifier.
   */
  Reference(std::string identifier, std::string fragment) {
    Reference((fragment == NULL) ? identifier : identifier + '#' + fragment);
  }

  /**
   * Constructor of absolute reference from its parts.
   * 
   * @param scheme
   *            The scheme ("http", "https" or "ftp").
   * @param hostName
   *            The host name or IP address.
   * @param hostPort
   *            The host port (default ports are correctly ignored).
   * @param path
   *            The path component for hierarchical identifiers.
   * @param query
   *            The optional query component for hierarchical identifiers.
   * @param fragment
   *            The optional fragment identifier.
   */
  Reference(std::string scheme, std::string hostName, int hostPort, std::string path,
            std::string query, std::string fragment) {
    Reference(toString(scheme, hostName, hostPort, path, query, fragment));
  }

  /**
   * Adds a parameter to the query component. The name and value are
   * automatically encoded if necessary.
   * 
   * @param name
   *            The parameter name.
   * @param value
   *            The optional parameter value.
   * @return The updated reference.
   */
  Reference addQueryParameter(std::string name, std::string value);

  /**
   * Adds a segment at the end of the path. If the current path doesn't end
   * with a slash character, one is inserted before the new segment value. The
   * value is automatically encoded if necessary.
   * 
   * @param value
   *            The segment value to add.
   * @return The updated reference.
   */
  Reference addSegment(std::string value);

  //@Override
  Reference clone();

  /**
   * Indicates whether some other object is "equal to" this one.
   * 
   * @param object
   *            The object to compare to.
   * @return True if this object is the same as the obj argument.
   */
  //@Override
  bool equals(Object object);

  /**
   * Returns the authority component for hierarchical identifiers. Includes
   * the user info, host name and the host port number.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The authority component for hierarchical identifiers.
   */
  std::string getAuthority();

  /**
   * Returns the optionnally decoded authority component.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded authority component.
   * @see #getAuthority()
   */
  std::string getAuthority(bool decode) {
    return decode ? decode(getAuthority()) : getAuthority();
  }

  /**
   * Returns the base reference for relative references.
   * 
   * @return The base reference for relative references.
   */
  Reference getBaseRef() {
    return this->baseRef;
  }

  /**
   * Returns the optional extensions for hierarchical identifiers. An
   * extensions part starts after the first '.' character of the last path
   * segment and ends with either the end of the segment of with the first ';'
   * character (matrix start). It is a token similar to file extensions
   * separated by '.' characters. The value can be ommited.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The extensions or NULL.
   * @see #getExtensionsAsArray()
   * @see #setExtensions(std::string)
   */
  std::string getExtensions();

  /**
   * Returns the extensions as an array or NULL if no extension is found.
   * 
   * @return The extensions as an array or NULL if no extension is found.
   * @see #getExtensions()
   */
  std::string[] getExtensionsAsArray();

  /**
   * Returns the fragment identifier.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The fragment identifier.
   */
  std::string getFragment();

  /**
   * Returns the optionnally decoded fragment identifier.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded fragment identifier.
   * @see #getFragment()
   */
  std::string getFragment(bool decode) {
    return decode ? decode(getFragment()) : getFragment();
  }

  /**
   * Returns the hierarchical part which is equivalent to the scheme specific
   * part less the query component.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The hierarchical part .
   */
  std::string getHierarchicalPart();

  /**
   * Returns the optionnally decoded hierarchical part.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded hierarchical part.
   * @see #getHierarchicalPart()
   */
  std::string getHierarchicalPart(bool decode) {
    return decode ? decode(getHierarchicalPart()) : getHierarchicalPart();
  }

  /**
   * Returns the host domain name component for server based hierarchical
   * identifiers. It can also be replaced by an IP address when no domain name
   * was registered.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The host domain name component for server based hierarchical
   *         identifiers.
   */
  std::string getHostDomain();

  /**
   * Returns the optionnally decoded host domain name component.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded host domain name component.
   * @see #getHostDomain()
   */
  std::string getHostDomain(bool decode) {
    return decode ? decode(getHostDomain()) : getHostDomain();
  }

  /**
   * Returns the host identifier. Includes the scheme, the host name and the
   * host port number.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The host identifier.
   */
  std::string getHostIdentifier();

  /**
   * Returns the optionnally decoded host identifier.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded host identifier.
   * @see #getHostIdentifier()
   */
  std::string getHostIdentifier(bool decode) {
    return decode ? decode(getHostIdentifier()) : getHostIdentifier();
  }

  /**
   * Returns the optional port number for server based hierarchical
   * identifiers.
   * 
   * @return The optional port number for server based hierarchical
   *         identifiers or -1 if the port number does not exist.
   */
  int getHostPort();

  /**
   * Returns the absolute resource identifier, without the fragment.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The absolute resource identifier, without the fragment.
   */
  std::string getIdentifier();

  /**
   * Returns the optionnally decoded absolute resource identifier.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded absolute resource identifier.
   * @see #getIdentifier()
   */
  std::string getIdentifier(bool decode) {
    return decode ? decode(getIdentifier()) : getIdentifier();
  }

  /**
   * Returns the last segment of a hierarchical path.<br>
   * For example the "/a/b/c" and "/a/b/c/" paths have the same segments: "a",
   * "b", "c.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The last segment of a hierarchical path.
   */
  std::string getLastSegment();

  /**
   * Returns the optionnally decoded last segment.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded last segment.
   * @see #getLastSegment()
   */
  std::string getLastSegment(bool decode) {
    return getLastSegment(decode, false);
  }

  /**
   * Returns the optionnally decoded last segment.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @param excludeMatrix
   * @return The optionnally decoded last segment.
   * @see #getLastSegment()
   */
  std::string getLastSegment(bool decode, bool excludeMatrix);

  /**
   * Returns the optional matrix for hierarchical identifiers. A matrix part
   * starts after the first ';' character of the last path segment. It is a
   * sequence of 'name=value' parameters separated by ';' characters. The
   * value can be ommited.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The matrix or NULL.
   */
  std::string getMatrix();

  /**
   * Returns the optionnally decoded matrix.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded matrix.
   * @see #getMatrix()
   */
  std::string getMatrix(bool decode) {
    return decode ? decode(getMatrix()) : getMatrix();
  }

  /**
   * Returns the optional matrix as a form.
   * 
   * @return The optional matrix component as a form.
   */
  Form getMatrixAsForm() {
    return new Form(getMatrix(), ';');
  }

  /**
   * Returns the optional matrix as a form submission.
   * 
   * @param characterSet
   *            The supported character encoding.
   * @return The optional matrix as a form.
   */
  Form getMatrixAsForm(CharacterSet characterSet) {
    return new Form(getMatrix(), characterSet, ';');
  }

  /**
   * Returns the parent reference of a hierarchical reference. The last slash
   * of the path will be considered as the end of the parent path.
   * 
   * @return The parent reference of a hierarchical reference.
   */
  Reference getParentRef();

  /**
   * Returns the path component for hierarchical identifiers. If not path is
   * available it returns NULL.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The path component for hierarchical identifiers.
   */
  std::string getPath();

  /**
   * Returns the optionnally decoded path component. If not path is available
   * it returns NULL.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded path component.
   * @see #getPath()
   */
  std::string getPath(bool decode) {
    return decode ? decode(getPath()) : getPath();
  }

  /**
   * Returns the optional query component for hierarchical identifiers.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The query component or NULL.
   */
  std::string getQuery();

  /**
   * Returns the optionnally decoded query component.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded query component.
   * @see #getQuery()
   */
  std::string getQuery(bool decode) {
    return decode ? decode(getQuery()) : getQuery();
  }

  /**
   * Returns the optional query component as a form.
   * 
   * @return The optional query component as a form.
   */
  Form getQueryAsForm() {
    return new Form(getQuery());
  }

  /**
   * Returns the optional query component as a form submission.
   * 
   * @param characterSet
   *            The supported character encoding.
   * @return The optional query component as a form submission.
   */
  Form getQueryAsForm(CharacterSet characterSet) {
    return new Form(getQuery(), characterSet);
  }

  /**
   * Returns the relative part of relative references, without the query and
   * fragment. If the reference is absolute, then NULL is returned.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The relative part.
   */
  std::string getRelativePart() {
    return isRelative() ? toString(false, false) : NULL;
  }

  /**
   * Returns the optionnally decoded relative part.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded relative part.
   * @see #getRelativePart()
   */
  std::string getRelativePart(bool decode) {
    return decode ? decode(getRelativePart()) : getRelativePart();
  }

  /**
   * Returns the current reference as a relative reference to the current base
   * reference. This method should only be invoked for absolute references,
   * otherwise an IllegalArgumentException will be raised.
   * 
   * @return The current reference as a relative reference to the current base
   *         reference.
   * @see #getRelativeRef(Reference)
   */
  Reference getRelativeRef() {
    return getRelativeRef(getBaseRef());
  }

  /**
   * Returns the current reference relatively to a base reference. This method
   * should only be invoked for absolute references, otherwise an
   * IllegalArgumentException will be raised.
   * 
   * @param base
   *            The base reference to use.
   * @throws IllegalArgumentException
   *             If the relative reference is computed although the reference
   *             or the base reference are not absolute or not hierarchical.
   * @return The current reference relatively to a base reference.
   */
  Reference getRelativeRef(Reference base);

  /**
   * Returns the part of the resource identifier remaining after the base
   * reference. Note that the optional fragment is not returned by this
   * method. Must be used with the following prerequisites:
   * <ul>
   * <li>the reference is absolute</li>
   * <li>the reference identifier starts with the resource baseRef</li>
   * </ul>
   * <br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The remaining resource part or NULL if the prerequisites are not
   *         satisfied.
   * @see #getRemainingPart(bool)
   */
  std::string getRemainingPart() {
    return getRemainingPart(false, true);
  }

  /**
   * Returns the optionally decoded remaining part.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionally decoded remaining part.
   * @see #getRemainingPart()
   */
  std::string getRemainingPart(bool decode) {
    return getRemainingPart(true, true);
  }

  /**
   * Returns the optionally decoded remaining part with or without the query
   * part of the reference.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @param query
   *            True if the query part should be returned, false otherwise.
   * @return The optionally decoded remaining part.
   * @see #getRemainingPart()
   */
  std::string getRemainingPart(bool decode, bool query);

  /**
   * Returns the scheme component.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The scheme component.
   */
  std::string getScheme();

  /**
   * Returns the optionnally decoded scheme component.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded scheme component.
   * @see #getScheme()
   */
  std::string getScheme(bool decode) {
    return decode ? decode(getScheme()) : getScheme();
  }

  /**
   * Returns the protocol associated with the scheme component.
   * 
   * @return The protocol associated with the scheme component.
   */
  Protocol getSchemeProtocol() {
    return Protocol.valueOf(getScheme());
  }

  /**
   * Returns the scheme specific part.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The scheme specific part.
   */
  std::string getSchemeSpecificPart();

  /**
   * Returns the optionnally decoded scheme specific part.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded scheme specific part.
   * @see #getSchemeSpecificPart()
   */
  std::string getSchemeSpecificPart(bool decode);

  /**
   * Returns the list of segments in a hierarchical path.<br>
   * A new list is created for each call.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The segments of a hierarchical path.
   */
  List<std::string> getSegments();

  /**
   * Returns the optionnally decoded list of segments.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded list of segments.
   * @see #getSegments()
   */
  List<std::string> getSegments(bool decode);

  /**
   * Returns the target reference. This method resolves relative references
   * against the base reference then normalize them.
   * 
   * @throws IllegalArgumentException
   *             If the base reference (after resolution) is not absolute.
   * @throws IllegalArgumentException
   *             If the reference is relative and not base reference has been
   *             provided.
   * 
   * @return The target reference.
   */
  Reference getTargetRef();

  /**
   * Returns the user info component for server based hierarchical
   * identifiers.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @return The user info component for server based hierarchical
   *         identifiers.
   */
  std::string getUserInfo();

  /**
   * Returns the optionnally decoded user info component.
   * 
   * @param decode
   *            Indicates if the result should be decoded using the
   *            {@link #decode(std::string)} method.
   * @return The optionnally decoded user info component.
   * @see #getUserInfo()
   */
  std::string getUserInfo(bool decode) {
    return decode ? decode(getUserInfo()) : getUserInfo();
  }

  /**
   * Indicates if this reference has file-like extensions on its last path
   * segment.
   * 
   * @return True if there is are extensions.
   * @see #getExtensions()
   */
  bool hasExtensions();

  /**
   * Indicates if this reference has a fragment identifier.
   * 
   * @return True if there is a fragment identifier.
   */
  bool hasFragment() {
    return (this->fragmentIndex != -1);
  }

  /**
   * Returns a hash code value for the object.
   * 
   * @return A hash code value for the object.
   */
  //@Override
  int hashCode() {
    return (this->internalRef == NULL) ? 0 : this->internalRef.hashCode();
  }

  /**
   * Indicates if this reference has a matrix.
   * 
   * @return True if there is a matrix.
   * @see #getMatrix()
   */
  bool hasMatrix() {
    return (getLastSegment().indexOf(';') != -1);
  }

  /**
   * Indicates if this reference has a query component.
   * 
   * @return True if there is a query.
   */
  bool hasQuery() {
    return (this->queryIndex != -1);
  }

  /**
   * Indicates if this reference has a scheme component.
   * 
   * @return True if there is a scheme component.
   */
  bool hasScheme() {
    return (this->schemeIndex != -1);
  }

  /**
   * Indicates if the reference is absolute.
   * 
   * @return True if the reference is absolute.
   */
  bool isAbsolute() {
    return (getScheme() != NULL);
  }

  /**
   * Returns true if both reference are equivalent, meaning that they resolve
   * to the same target reference.
   * 
   * @param ref
   *            The reference to compare.
   * @return True if both reference are equivalent.
   */
  bool isEquivalentTo(Reference ref) {
    return getTargetRef().equals(ref.getTargetRef());
  }

  /**
   * Indicates if the identifier is hierarchical.
   * 
   * @return True if the identifier is hierarchical, false if it is opaque.
   */
  bool isHierarchical() {
    return isRelative() || (getSchemeSpecificPart().charAt(0) == '/');
  }

  /**
   * Indicates if the identifier is opaque.
   * 
   * @return True if the identifier is opaque, false if it is hierarchical.
   */
  bool isOpaque() {
    return isAbsolute() && (getSchemeSpecificPart().charAt(0) != '/');
  }

  /**
   * Indicates if the reference is a parent of the hierarchical child
   * reference.
   * 
   * @param childRef
   *            The hierarchical reference.
   * @return True if the reference is a parent of the hierarchical child
   *         reference.
   */
  bool isParent(Reference childRef);

  /**
   * Indicates if the reference is relative.
   * 
   * @return True if the reference is relative.
   */
  bool isRelative() {
    return (getScheme() == NULL);
  }

  /**
   * Normalizes the reference. Useful before comparison between references or
   * when building a target reference from a base and a relative references.
   * 
   * @return The current reference.
   */
  Reference normalize();

  /**
   * Sets the authority component for hierarchical identifiers.
   * 
   * @param authority
   *            The authority component for hierarchical identifiers.
   */
  void setAuthority(std::string authority);

  /**
   * Sets the base reference for relative references.
   * 
   * @param baseRef
   *            The base reference for relative references.
   */
  void setBaseRef(Reference baseRef) {
    this->baseRef = baseRef;
  }

  /**
   * Sets the base reference for relative references.
   * 
   * @param baseUri
   *            The base URI for relative references.
   */
  void setBaseRef(std::string baseUri) {
    setBaseRef(new Reference(baseUri));
  }

  /**
   * Sets the extensions for hierarchical identifiers. An extensions part
   * starts after the first '.' character of the last path segment and ends
   * with either the end of the segment of with the first ';' character
   * (matrix start). It is a token similar to file extensions separated by '.'
   * characters. The value can be ommited.<br>
   * Note that no URI decoding is done by this method.
   * 
   * @param extensions
   *            The extensions to set or NULL (without leading or trailing
   *            dots).
   * @see #getExtensions()
   * @see #getExtensionsAsArray()
   * @see #setExtensions(std::string[])
   */
  void setExtensions(std::string extensions);

  /**
   * Sets the extensions based on an array of extension tokens (without dots).
   * 
   * @param extensions
   *            The array of extensions.
   * @see #getExtensions()
   * @see #getExtensionsAsArray()
   * @see #setExtensions(std::string)
   */
  void setExtensions(std::string[] extensions);

  /**
   * Sets the fragment identifier.
   * 
   * @param fragment
   *            The fragment identifier.
   * @throws IllegalArgumentException
   *             if the fragment parameter contains the fragment delimiter
   *             ('#').
   */
  void setFragment(std::string fragment);

  /**
   * Sets the host domain component for server based hierarchical identifiers.
   * 
   * @param domain
   *            The host component for server based hierarchical identifiers.
   */
  void setHostDomain(std::string domain);

  /**
   * Sets the optional port number for server based hierarchical identifiers.
   * 
   * @param port
   *            The optional port number for server based hierarchical
   *            identifiers.
   * @throws IllegalArgumentException
   *             If the autority has not been defined.
   */
  void setHostPort(Integer port);

  /**
   * Sets the absolute resource identifier.
   * 
   * @param identifier
   *            The absolute resource identifier.
   * @throws IllegalArgumentException
   *             If the identifier parameter contains the fragment delimiter
   *             ('#').
   */
  void setIdentifier(std::string identifier);

  /**
   * Sets the last segment of the path. If no path is available, then it
   * creates one and adds a slash in front of the given last segmetn. <br>
   * Note that no URI decoding is done by this method.
   * 
   * @param lastSegment
   *            The last segment of a hierarchical path.
   */
  void setLastSegment(std::string lastSegment);

  /**
   * Sets the path component for hierarchical identifiers.
   * 
   * @param path
   *            The path component for hierarchical identifiers.
   */
  void setPath(std::string path);

  /**
   * Sets the scheme component based on this protocol.
   * 
   * @param protocol
   *            The protocol of the scheme component.
   */
  void setProtocol(Protocol protocol) {
    setScheme(protocol.getSchemeName());
  }

  /**
   * Sets the query component for hierarchical identifiers.
   * 
   * @param query
   *            The query component for hierarchical identifiers.
   */
  void setQuery(std::string query);

  /**
   * Sets the relative part for relative references only.
   * 
   * @param relativePart
   *            The relative part to set.
   */
  void setRelativePart(std::string relativePart);

  /**
   * Sets the scheme component.
   * 
   * @param scheme
   *            The scheme component.
   */
  void setScheme(std::string scheme);

  /**
   * Sets the scheme specific part.
   * 
   * @param schemeSpecificPart
   *            The scheme specific part.
   */
  void setSchemeSpecificPart(std::string schemeSpecificPart);

  /**
   * Sets the segments of a hierarchical path.<br>
   * A new absolute path will replace any existing one.
   * 
   * @param segments
   *            The segments of the hierarchical path.
   */
  void setSegments(List<std::string> segments);

  /**
   * Sets the user info component for server based hierarchical identifiers.
   * 
   * @param userInfo
   *            The user info component for server based hierarchical
   *            identifiers.
   * @throws IllegalArgumentException
   *             If the autority part has not been defined.
   */
  void setUserInfo(std::string userInfo);

  /**
   * Returns the reference as an URI string.
   * 
   * @return The reference as an URI string.
   */
  //@Override
  std::string toString() {
    return this->internalRef;
  }

  /**
   * Returns the URI reference string.
   * 
   * @param query
   *            Indicates if the query should be included;
   * @param fragment
   *            Indicates if the fragment should be included;
   * @return The URI reference string.
   */
  std::string toString(bool query, bool fragment);

  /**
   * Converts to a {@link java.net.URI} instance. Note that relative
   * references are resolved before conversion using the
   * {@link #getTargetRef()} method.
   * 
   * @return A {@link java.net.URI} instance.
   */
  java.net.URI toUri() {
    return java.net.URI.create(getTargetRef().toString());
  }

  /**
   * Converts to a {@link java.net.URL} instance. Note that relative
   * references are resolved before conversion using the
   * {@link #getTargetRef()} method.
   * 
   * @return A {@link java.net.URL} instance.
   */
  java.net.URL Reference::toUrl() {
    java.net.URL result = NULL;

    try {
      result = new java.net.URL(getTargetRef().toString());
    } catch (java.net.MalformedURLException e) {
      throw new IllegalArgumentException("Malformed URL exception", e);
    }

    return result;
  }

 private:

  /**
   * Indicates if the given character is upper case (A-Z).
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is upper case (A-Z).
   */
  static bool isUpperCase(int character) {
    return (character >= 'A') && (character <= 'Z');
  }

  /**
   * Indicates if the given character is alphabetical (a-z or A-Z).
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is alphabetical (a-z or A-Z).
   */
  static bool isAlpha(int character) {
    return isUpperCase(character) || isLowerCase(character);
  }

  /**
   * Indicates if the given character is a digit (0-9).
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is a digit (0-9).
   */
  static bool isDigit(int character) {
    return (character >= '0') && (character <= '9');
  }

  /**
   * Indicates if the given character is lower case (a-z).
   * 
   * @param character
   *            The character to test.
   * @return True if the given character is lower case (a-z).
   */
  static bool isLowerCase(int character) {
    return (character >= 'a') && (character <= 'z');
  }

  /**
   * Checks if all characters are valid and encodes invalid characters if
   * necessary.
   * 
   * @param uriRef
   *            The URI reference to check.
   * @return The original reference, eventually with invalid URI characters
   *         encoded.
   */
  std::string encodeInvalidCharacters(std::string uriRef)
      throws IllegalArgumentException;

  /**
   * Removes the last segement from the output builder.
   * 
   * @param output
   *            The output builder to update.
   */
  void removeLastSegment(StringBuilder output);

  /**
   * Updates internal indexes.
   */
  void updateIndexes();


 private:

  /** The base reference for relative references. */
  volatile Reference baseRef;

  /** The fragment separator index. */
  volatile int fragmentIndex;

  /** The internal reference. */
  volatile std::string internalRef;

  /** The query separator index. */
  volatile int queryIndex;

  /** The scheme separator index. */
  volatile int schemeIndex;
};

} // namespace data
} // namespace echo

#endif // _ECHO_DATA_REFERENCE_H_


